#!/usr/bin/env python3
"""
WavNote Test Coverage Analysis Tool
===================================

This script analyzes Flutter test coverage data and provides detailed insights
about test coverage across the Clean Architecture layers of the WavNote app.

WHAT IT DOES:
- Reads the LCOV coverage file generated by 'flutter test --coverage'
- Categorizes files by Clean Architecture layers (BLoC, Repository, Service, etc.)
- Calculates coverage percentages for each layer and file
- Identifies areas that need more testing
- Provides actionable recommendations for improving coverage

HOW TO USE:
1. Run: flutter test --coverage
2. Run: python3 analyze_coverage.py
3. Review the detailed coverage report

WHY IT'S HELPFUL:
- Shows exactly where your test coverage is weak
- Helps prioritize which files/layers to test next
- Tracks progress toward professional 75%+ coverage goals
- Provides Clean Architecture-aware analysis
"""

import re
from pathlib import Path

def analyze_lcov_coverage(lcov_file_path):
    """
    Main function that parses the LCOV coverage file and extracts statistics.
    
    LCOV FORMAT EXPLANATION:
    - SF: Source File path
    - LF: Lines Found (total executable lines in file)
    - LH: Lines Hit (lines covered by tests)
    - Each file ends with 'end_of_record'
    
    Args:
        lcov_file_path: Path to the coverage/lcov.info file
        
    Returns:
        Dictionary with overall stats, per-file stats, and per-layer stats
    """
    
    # Read the entire LCOV file content
    with open(lcov_file_path, 'r') as f:
        content = f.read()
    
    # Split the file into individual file records
    # Each file's coverage data is separated by 'end_of_record'
    records = content.split('end_of_record\n')
    
    # Initialize counters for overall statistics
    total_lines = 0        # Total executable lines across all files
    covered_lines = 0      # Total lines covered by tests
    file_coverage = {}     # Coverage data for each individual file
    layer_coverage = {}    # Coverage data grouped by architecture layer
    
    # Process each file's coverage record
    for record in records:
        # Skip empty records
        if not record.strip():
            continue
            
        # Extract the file path (SF: line)
        # Example: "SF:lib/presentation/bloc/recording/recording_bloc.dart"
        sf_match = re.search(r'^SF:(.+)$', record, re.MULTILINE)
        if not sf_match:
            continue  # Skip if no file path found
            
        file_path = sf_match.group(1)
        
        # Extract lines found (LF:) and lines hit (LH:)
        # LF: Total executable lines in the file
        # LH: Lines that were executed during tests
        lf_match = re.search(r'^LF:(\d+)$', record, re.MULTILINE)
        lh_match = re.search(r'^LH:(\d+)$', record, re.MULTILINE)
        
        if lf_match and lh_match:
            lines_found = int(lf_match.group(1))
            lines_hit = int(lh_match.group(1))
            
            # Add to overall totals
            total_lines += lines_found
            covered_lines += lines_hit
            
            # Calculate coverage percentage for this file
            if lines_found > 0:
                coverage_percent = (lines_hit / lines_found) * 100
                
                # Store file-specific coverage data
                file_coverage[file_path] = {
                    'lines_found': lines_found,
                    'lines_hit': lines_hit,
                    'coverage_percent': coverage_percent
                }
                
                # Categorize file by Clean Architecture layer
                layer = categorize_file_by_layer(file_path)
                
                # Initialize layer data if first file in this layer
                if layer not in layer_coverage:
                    layer_coverage[layer] = {
                        'lines_found': 0, 
                        'lines_hit': 0, 
                        'files': []
                    }
                
                # Add this file's data to its layer totals
                layer_coverage[layer]['lines_found'] += lines_found
                layer_coverage[layer]['lines_hit'] += lines_hit
                layer_coverage[layer]['files'].append(file_path)
    
    # Calculate overall coverage percentage
    overall_coverage = (covered_lines / total_lines * 100) if total_lines > 0 else 0
    
    # Return comprehensive statistics
    return {
        'overall': {
            'total_lines': total_lines,
            'covered_lines': covered_lines,
            'coverage_percent': overall_coverage,
            'total_files': len(file_coverage)
        },
        'file_coverage': file_coverage,
        'layer_coverage': layer_coverage
    }

def categorize_file_by_layer(file_path):
    """
    Categorizes a file by its Clean Architecture layer based on its path.
    
    CLEAN ARCHITECTURE LAYERS EXPLAINED:
    - BLoC Layer: State management (presentation/bloc/ files)
    - Repository Layer: Data access interfaces and implementations
    - Service Layer: External service integrations (audio, location, etc.)
    - Use Case Layer: Business logic operations
    - Presentation Layer: UI widgets and screens
    - Data/Domain Layer: Models and entities
    - Core Layer: Shared utilities, constants, enums
    
    Args:
        file_path: The file path from the coverage data
        
    Returns:
        String describing which architectural layer this file belongs to
    """
    
    # Check file path patterns to determine layer
    if '/bloc/' in file_path or file_path.endswith('_bloc.dart'):
        return 'BLoC Layer'  # State management
    elif '/repositories/' in file_path or file_path.endswith('_repository.dart'):
        return 'Repository Layer'  # Data access
    elif '/services/' in file_path or file_path.endswith('_service.dart'):
        return 'Service Layer'  # External integrations
    elif '/usecases/' in file_path or file_path.endswith('_usecase.dart'):
        return 'Use Case Layer'  # Business logic
    elif '/widgets/' in file_path or '/screens/' in file_path:
        return 'Presentation Layer'  # UI components
    elif '/models/' in file_path or '/entities/' in file_path:
        return 'Data/Domain Layer'  # Data structures
    elif '/core/' in file_path:
        return 'Core Layer'  # Shared utilities
    else:
        return 'Other'  # Doesn't fit standard patterns

def print_coverage_report(stats):
    """
    Prints a comprehensive, formatted coverage report to the console.
    
    REPORT SECTIONS:
    1. Overall Coverage Summary - total project statistics
    2. Coverage by Architecture Layer - shows which layers need work
    3. Files with Low Coverage - identifies problem areas
    4. Files with High Coverage - shows good examples
    5. Coverage Goals Assessment - progress toward professional standards
    6. Recommendations - prioritized action items
    
    Args:
        stats: Dictionary containing all coverage statistics
    """
    
    # Print header
    print("=" * 80)
    print("WAVNOTE FLUTTER PROJECT - TEST COVERAGE ANALYSIS")
    print("=" * 80)
    
    # SECTION 1: Overall Coverage Summary
    overall = stats['overall']
    print(f"\nüìä OVERALL COVERAGE SUMMARY")
    print(f"{'‚îÄ' * 40}")
    print(f"Total Files Analyzed:     {overall['total_files']}")
    print(f"Total Lines of Code:      {overall['total_lines']:,}")  # :, adds comma separators
    print(f"Lines Covered by Tests:   {overall['covered_lines']:,}")
    print(f"Overall Coverage:         {overall['coverage_percent']:.1f}%")  # :.1f shows 1 decimal
    
    # Determine coverage status with visual indicators
    if overall['coverage_percent'] >= 80:
        status = "üü¢ EXCELLENT"        # Professional/enterprise level
    elif overall['coverage_percent'] >= 70:
        status = "üü° GOOD"             # Professional minimum
    elif overall['coverage_percent'] >= 50:
        status = "üü† MODERATE"         # Decent but needs improvement
    else:
        status = "üî¥ NEEDS IMPROVEMENT"  # Below acceptable standards
    
    print(f"Coverage Status:          {status}")
    
    # SECTION 2: Coverage by Architecture Layer
    print(f"\nüèóÔ∏è  COVERAGE BY ARCHITECTURE LAYER")
    print(f"{'‚îÄ' * 60}")
    print("This shows which parts of your Clean Architecture need more testing:")
    
    # Sort layers alphabetically for consistent reporting
    for layer, data in sorted(stats['layer_coverage'].items()):
        if data['lines_found'] > 0:
            # Calculate layer coverage percentage
            layer_coverage = (data['lines_hit'] / data['lines_found']) * 100
            # Format: LayerName   XX.X% (covered/total) [N files]
            print(f"{layer:<20} {layer_coverage:>6.1f}% ({data['lines_hit']:>4}/{data['lines_found']:<4}) [{len(data['files'])} files]")
    
    # SECTION 3: Files with Low Coverage
    print(f"\nüìÅ FILES WITH LOW COVERAGE (< 50%)")
    print(f"{'‚îÄ' * 60}")
    print("These files need more tests - prioritize testing these:")
    
    # Find all files below 50% coverage
    low_coverage_files = []
    for file_path, data in stats['file_coverage'].items():
        if data['coverage_percent'] < 50:
            low_coverage_files.append((file_path, data))
    
    # Sort by coverage percentage (worst first)
    low_coverage_files.sort(key=lambda x: x[1]['coverage_percent'])
    
    if low_coverage_files:
        # Show worst 15 files to avoid overwhelming output
        for file_path, data in low_coverage_files[:15]:
            short_path = file_path.replace('lib/', '')  # Remove lib/ prefix for readability
            print(f"{short_path:<50} {data['coverage_percent']:>6.1f}%")
    else:
        print("üéâ All files have >= 50% coverage!")
    
    # SECTION 4: Files with High Coverage
    print(f"\nüèÜ FILES WITH HIGH COVERAGE (>= 80%)")
    print(f"{'‚îÄ' * 60}")
    print("These files are well-tested - use them as examples:")
    
    # Find all files with good coverage
    high_coverage_files = []
    for file_path, data in stats['file_coverage'].items():
        if data['coverage_percent'] >= 80:
            high_coverage_files.append((file_path, data))
    
    # Sort by coverage percentage (best first)
    high_coverage_files.sort(key=lambda x: x[1]['coverage_percent'], reverse=True)
    
    if high_coverage_files:
        # Show top 10 to highlight good examples
        for file_path, data in high_coverage_files[:10]:
            short_path = file_path.replace('lib/', '')
            print(f"{short_path:<50} {data['coverage_percent']:>6.1f}%")
    else:
        print("No files have >= 80% coverage yet.")
    
    # SECTION 5: Coverage Goals Assessment
    print(f"\nüìà COVERAGE GOALS ASSESSMENT")
    print(f"{'‚îÄ' * 40}")
    target_coverage = 75  # Professional standard for production apps
    
    if overall['coverage_percent'] >= target_coverage:
        print(f"‚úÖ GOAL ACHIEVED: {overall['coverage_percent']:.1f}% >= {target_coverage}%")
        print("Your app has professional-level test coverage!")
    else:
        # Calculate exactly how many more lines need to be covered
        needed_lines = int((target_coverage / 100) * overall['total_lines']) - overall['covered_lines']
        print(f"üéØ TARGET: {target_coverage}% coverage (professional standard)")
        print(f"üìä CURRENT: {overall['coverage_percent']:.1f}%")
        print(f"üìà NEEDED: {needed_lines:,} more lines to cover")
        print(f"üìâ GAP: {target_coverage - overall['coverage_percent']:.1f} percentage points")
    
    # SECTION 6: Recommendations
    print(f"\nüîç RECOMMENDATIONS")
    print(f"{'‚îÄ' * 40}")
    print("Priority order for improving coverage (focus on these layers first):")
    
    # Calculate priority based on current coverage and potential impact
    layer_priorities = []
    for layer, data in stats['layer_coverage'].items():
        if data['lines_found'] > 0:
            coverage = (data['lines_hit'] / data['lines_found']) * 100
            impact = data['lines_found'] - data['lines_hit']  # Uncovered lines = potential improvement
            layer_priorities.append((layer, coverage, impact))
    
    # Sort by coverage (lowest first), then by impact (highest first)
    # This prioritizes layers with low coverage AND high impact
    layer_priorities.sort(key=lambda x: (x[1], -x[2]))
    
    for i, (layer, coverage, impact) in enumerate(layer_priorities[:5], 1):
        print(f"{i}. {layer}: {coverage:.1f}% coverage, {impact} lines to cover")
        
    print(f"\nüí° TIPS:")
    print("- Focus on the Service and Repository layers first (biggest impact)")
    print("- Add unit tests for BLoC state management")
    print("- Create widget tests for Presentation layer components")
    print("- Use mock objects to test complex integrations")

if __name__ == "__main__":
    """
    Main execution block - runs when script is called directly.
    
    USAGE:
    1. First run: flutter test --coverage
    2. Then run: python3 analyze_coverage.py
    """
    
    # Look for the standard Flutter coverage file location
    lcov_path = Path("coverage/lcov.info")
    
    # Check if coverage file exists
    if not lcov_path.exists():
        print("‚ùå Error: coverage/lcov.info not found")
        print("Please run 'flutter test --coverage' first to generate coverage data")
        print("This will create the coverage/lcov.info file that this script analyzes")
        exit(1)
    
    try:
        # Parse the coverage data and generate the report
        print("üîç Analyzing test coverage data...")
        stats = analyze_lcov_coverage(lcov_path)
        print_coverage_report(stats)
        print(f"\n‚úÖ Analysis complete! Use this data to improve your test coverage.")
        
    except Exception as e:
        print(f"‚ùå Error analyzing coverage: {e}")
        print("Check that the coverage/lcov.info file is valid and properly formatted")
        exit(1)